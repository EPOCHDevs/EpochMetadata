{
  "id": "algorithm_001",
  "name": "Volatility-Adjusted Momentum Strategy",
  "description": "This strategy utilizes a custom indicator called the Volatility-Adjusted Momentum Oscillator (VAMO) to combine momentum and volatility for trading decisions. It aims to enhance the accuracy of momentum signals by incorporating a volatility measure, providing a more robust trading approach.",
  "algorithm_type": "Momentum",
  "prompt": "import pandas as pd\nimport numpy as np\nimport talib\n\ndef trading_strategy(data):\n    # Custom indicator: Volatility-Adjusted Momentum Oscillator (VAMO)\n    # Combines momentum and volatility in a unique way\n    \n    close = data['close']\n    high = data['high']\n    low = data['low']\n    volume = data['volume']\n\n    # Step 1: Calculate a volatility measure: Median Price ATR-like using TALib ATR but with median price\n    median_price = (high + low) / 2\n    # ATR with median price series (approximate by using median_price instead of close)\n    atr_median = talib.ATR(high.values, low.values, median_price.values, timeperiod=14)\n    \n    # Step 2: Calculate raw momentum as rate of change of price\n    roc = talib.ROC(close.values, timeperiod=10)\n    \n    # Step 3: Normalize momentum by recent volatility to penalize high volatility moves\n    # Avoid division by zero:\n    volatility_adj = roc / (atr_median + 1e-6)\n    \n    # Step 4: Smooth with a zero-lag EMA (custom zero-lag using double EMA approach)\n    ema1 = talib.EMA(volatility_adj, timeperiod=10)\n    ema2 = talib.EMA(ema1, timeperiod=10)\n    zero_lag_ema = 2 * ema1 - ema2\n    \n    # Step 5: Define thresholds with adaptive bands based on volatility to generate signals\n    band = np.nanstd(volatility_adj[-50:])  # stddev of last 50 points as dynamic threshold\n    upper_band = band * 0.7\n    lower_band = -upper_band\n\n    data['vam_osc'] = zero_lag_ema\n\n    # Step 6: Signal generation\n    signals = np.zeros(len(data))\n    # Buy when VAMO crosses above lower_band from below (momentum picks up normalized by low vol)\n    cross_up = (data['vam_osc'].shift(1) < lower_band) & (data['vam_osc'] > lower_band)\n    signals[cross_up] = 1\n    # Sell when VAMO crosses below upper_band from above (momentum fading or reversal)\n    cross_down = (data['vam_osc'].shift(1) > upper_band) & (data['vam_osc'] < upper_band)\n    signals[cross_down] = -1\n    \n    data['signal'] = signals\n    return data",
  "blueprint": {
    "nodes": [
      {
        "id": "mkt",
        "type": "market_data_source",
        "options": [],
        "metadata": {
          "parentId": null
        },
        "timeframe": {
          "type": "day",
          "interval": 1
        }
      },
      {
        "id": "atr1",
        "type": "atr",
        "options": [
          {
            "id": "period",
            "value": 14,
            "name": "",
            "isExposed": false
          }
        ],
        "metadata": {
          "parentId": null
        },
        "timeframe": {
          "type": "day",
          "interval": 1
        }
      },
      {
        "id": "roc1",
        "type": "roc",
        "options": [
          {
            "id": "period",
            "value": 10,
            "name": "",
            "isExposed": false
          }
        ],
        "metadata": {
          "parentId": null
        },
        "timeframe": null
      },
      {
        "id": "div1",
        "type": "div",
        "options": [],
        "metadata": {
          "parentId": null
        },
        "timeframe": null
      },
      {
        "id": "zlema1",
        "type": "zlema",
        "options": [
          {
            "id": "period",
            "value": 10,
            "name": "",
            "isExposed": false
          }
        ],
        "metadata": {
          "parentId": null
        },
        "timeframe": null
      },
      {
        "id": "adapt1",
        "type": "trade_executor_adapter",
        "options": [],
        "metadata": {
          "parentId": null
        },
        "timeframe": null
      },
      {
        "id": "exec1",
        "type": "trade_signal_executor",
        "options": [
          {
            "id": "closeIfIndecisive",
            "value": false,
            "name": "",
            "isExposed": false
          }
        ],
        "metadata": {
          "parentId": null
        },
        "timeframe": null
      }
    ],
    "edges": [
      {
        "source": {
          "id": "mkt",
          "handle": "c"
        },
        "target": {
          "id": "roc1",
          "handle": "*"
        }
      },
      {
        "source": {
          "id": "roc1",
          "handle": "result"
        },
        "target": {
          "id": "div1",
          "handle": "*0"
        }
      },
      {
        "source": {
          "id": "atr1",
          "handle": "result"
        },
        "target": {
          "id": "div1",
          "handle": "*1"
        }
      },
      {
        "source": {
          "id": "div1",
          "handle": "result"
        },
        "target": {
          "id": "zlema1",
          "handle": "*"
        }
      },
      {
        "source": {
          "id": "zlema1",
          "handle": "result"
        },
        "target": {
          "id": "adapt1",
          "handle": "*"
        }
      },
      {
        "source": {
          "id": "adapt1",
          "handle": "long"
        },
        "target": {
          "id": "exec1",
          "handle": "long"
        }
      },
      {
        "source": {
          "id": "adapt1",
          "handle": "short"
        },
        "target": {
          "id": "exec1",
          "handle": "short"
        }
      }
    ]
  },
  "timestamp": "2025-06-23T15:48:27.278774",
  "tags": [
    "momentum",
    "volatility",
    "trading",
    "technical analysis",
    "algorithm"
  ]
}