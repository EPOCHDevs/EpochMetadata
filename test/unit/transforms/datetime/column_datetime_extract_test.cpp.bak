//
// Created by Claude Code
// Test for column_datetime_extract transform
//

#include <epoch_script/core/constants.h>
#include "epoch_script/strategy/registration.h"
#include <epoch_script/transforms/core/config_helper.h>
#include <epoch_script/transforms/core/itransform.h>
#include <epoch_script/transforms/core/transform_configuration.h>
#include <epoch_script/transforms/core/transform_registry.h>
#include "transforms/components/datetime/index_datetime_extract.h"
#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_string.hpp>
#include <epoch_core/catch_defs.h>
#include <epoch_frame/factory/index_factory.h>
#include <epoch_frame/factory/array_factory.h>
#include <epoch_frame/datetime.h>

using namespace epoch_core;
using namespace epoch_script;
using namespace epoch_script::transform;
using namespace std::chrono_literals;
using namespace epoch_frame;

// Helper function to create a test dataframe with timestamp column
DataFrame createTestDataFrameWithTimestamp() {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d},
       epoch_frame::DateTime{2020y, std::chrono::January, 3d}});

  // Create timestamp column with different dates
  std::vector<epoch_frame::DateTime> timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 15d, 14h, 30min, 45s},
      epoch_frame::DateTime{2021y, std::chrono::March, 20d, 9h, 15min, 30s},
      epoch_frame::DateTime{2022y, std::chrono::December, 31d, 23h, 59min, 59s}};

  auto timestamp_array = epoch_frame::factory::array::make_timestamp_array(timestamps);

  arrow::FieldVector fields = {
      arrow::field("price", arrow::float64()),
      arrow::field("observation_date", timestamp_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {
      epoch_frame::factory::array::make_numeric_array<double>({10.0, 20.0, 30.0}),
      timestamp_array};

  auto table = arrow::Table::Make(schema, arrays);
  return DataFrame(index, table);
}

TEST_CASE("column_datetime_extract - year component", "[datetime][extract][column]") {
  auto input = createTestDataFrameWithTimestamp();
  auto index = input.index();

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: column_datetime_extract
id: year_extract
options:
  component: "year"
inputs:
  SLOT: observation_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  REQUIRE(output.size() == 3);
  REQUIRE(output.contains(config.GetOutputId()));

  auto series = output[config.GetOutputId()];
  REQUIRE(series.size() == 3);

  // Verify year values
  auto year_array = std::static_pointer_cast<arrow::Int64Array>(series.array());
  REQUIRE(year_array->Value(0) == 2020);
  REQUIRE(year_array->Value(1) == 2021);
  REQUIRE(year_array->Value(2) == 2022);
}

TEST_CASE("column_datetime_extract - month component", "[datetime][extract][column]") {
  auto input = createTestDataFrameWithTimestamp();

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: column_datetime_extract
id: month_extract
options:
  component: "month"
inputs:
  SLOT: observation_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto month_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  // January=1, March=3, December=12
  REQUIRE(month_array->Value(0) == 1);
  REQUIRE(month_array->Value(1) == 3);
  REQUIRE(month_array->Value(2) == 12);
}

TEST_CASE("column_datetime_extract - day component", "[datetime][extract][column]") {
  auto input = createTestDataFrameWithTimestamp();

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: column_datetime_extract
id: day_extract
options:
  component: "day"
inputs:
  SLOT: observation_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto day_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(day_array->Value(0) == 15);
  REQUIRE(day_array->Value(1) == 20);
  REQUIRE(day_array->Value(2) == 31);
}

TEST_CASE("column_datetime_extract - time components", "[datetime][extract][column]") {
  auto input = createTestDataFrameWithTimestamp();

  SECTION("hour component") {
    TransformConfiguration config =
        TransformConfiguration{TransformDefinition{YAML::Load(std::format(
            R"(
type: column_datetime_extract
id: hour_extract
options:
  component: "hour"
inputs:
  SLOT: observation_date
timeframe: {}
)",
            epoch_script::EpochStratifyXConstants::instance()
                .DAILY_FREQUENCY.Serialize()))}};

    auto transformBase = MAKE_TRANSFORM(config);
    auto transform = dynamic_cast<ITransform *>(transformBase.get());
    DataFrame output = transform->TransformData(input);

    auto series = output[config.GetOutputId()];
    auto hour_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

    REQUIRE(hour_array->Value(0) == 14);
    REQUIRE(hour_array->Value(1) == 9);
    REQUIRE(hour_array->Value(2) == 23);
  }

  SECTION("minute component") {
    TransformConfiguration config =
        TransformConfiguration{TransformDefinition{YAML::Load(std::format(
            R"(
type: column_datetime_extract
id: minute_extract
options:
  component: "minute"
inputs:
  SLOT: observation_date
timeframe: {}
)",
            epoch_script::EpochStratifyXConstants::instance()
                .DAILY_FREQUENCY.Serialize()))}};

    auto transformBase = MAKE_TRANSFORM(config);
    auto transform = dynamic_cast<ITransform *>(transformBase.get());
    DataFrame output = transform->TransformData(input);

    auto series = output[config.GetOutputId()];
    auto minute_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

    REQUIRE(minute_array->Value(0) == 30);
    REQUIRE(minute_array->Value(1) == 15);
    REQUIRE(minute_array->Value(2) == 59);
  }

  SECTION("second component") {
    TransformConfiguration config =
        TransformConfiguration{TransformDefinition{YAML::Load(std::format(
            R"(
type: column_datetime_extract
id: second_extract
options:
  component: "second"
inputs:
  SLOT: observation_date
timeframe: {}
)",
            epoch_script::EpochStratifyXConstants::instance()
                .DAILY_FREQUENCY.Serialize()))}};

    auto transformBase = MAKE_TRANSFORM(config);
    auto transform = dynamic_cast<ITransform *>(transformBase.get());
    DataFrame output = transform->TransformData(input);

    auto series = output[config.GetOutputId()];
    auto second_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

    REQUIRE(second_array->Value(0) == 45);
    REQUIRE(second_array->Value(1) == 30);
    REQUIRE(second_array->Value(2) == 59);
  }
}

TEST_CASE("column_datetime_extract - quarter component", "[datetime][extract][column]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d},
       epoch_frame::DateTime{2020y, std::chrono::January, 3d},
       epoch_frame::DateTime{2020y, std::chrono::January, 4d}});

  std::vector<epoch_frame::DateTime> timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 15d},   // Q1
      epoch_frame::DateTime{2020y, std::chrono::April, 10d},     // Q2
      epoch_frame::DateTime{2020y, std::chrono::July, 20d},      // Q3
      epoch_frame::DateTime{2020y, std::chrono::October, 5d}};  // Q4

  auto timestamp_array = epoch_frame::factory::array::make_timestamp_array(timestamps);

  arrow::FieldVector fields = {
      arrow::field("price", arrow::float64()),
      arrow::field("period_end", timestamp_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {
      epoch_frame::factory::array::make_numeric_array<double>({10.0, 20.0, 30.0, 40.0}),
      timestamp_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: column_datetime_extract
id: quarter_extract
options:
  component: "quarter"
inputs:
  SLOT: period_end
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto quarter_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(quarter_array->Value(0) == 1);
  REQUIRE(quarter_array->Value(1) == 2);
  REQUIRE(quarter_array->Value(2) == 3);
  REQUIRE(quarter_array->Value(3) == 4);
}

TEST_CASE("column_datetime_extract - is_leap_year component", "[datetime][extract][column]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d},
       epoch_frame::DateTime{2020y, std::chrono::January, 3d}});

  std::vector<epoch_frame::DateTime> timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d},   // Leap year
      epoch_frame::DateTime{2021y, std::chrono::January, 1d},   // Not leap year
      epoch_frame::DateTime{2024y, std::chrono::January, 1d}}; // Leap year

  auto timestamp_array = epoch_frame::factory::array::make_timestamp_array(timestamps);

  arrow::FieldVector fields = {
      arrow::field("price", arrow::float64()),
      arrow::field("fiscal_year_end", timestamp_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {
      epoch_frame::factory::array::make_numeric_array<double>({10.0, 20.0, 30.0}),
      timestamp_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: column_datetime_extract
id: leap_extract
options:
  component: "is_leap_year"
inputs:
  SLOT: fiscal_year_end
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto leap_array = std::static_pointer_cast<arrow::BooleanArray>(series.array());

  REQUIRE(leap_array->Value(0) == true);   // 2020 is leap year
  REQUIRE(leap_array->Value(1) == false);  // 2021 is not leap year
  REQUIRE(leap_array->Value(2) == true);   // 2024 is leap year
}

TEST_CASE("column_datetime_extract - default component is year", "[datetime][extract][column]") {
  auto input = createTestDataFrameWithTimestamp();

  // Don't specify component option - should default to year
  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: column_datetime_extract
id: default_extract
inputs:
  SLOT: observation_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto year_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  // Should extract year by default
  REQUIRE(year_array->Value(0) == 2020);
  REQUIRE(year_array->Value(1) == 2021);
  REQUIRE(year_array->Value(2) == 2022);
}
