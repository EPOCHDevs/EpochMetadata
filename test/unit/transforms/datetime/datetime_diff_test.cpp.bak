//
// Created by Claude Code
// Test for datetime_diff transform
//

#include <epoch_script/core/constants.h>
#include "epoch_script/strategy/registration.h"
#include <epoch_script/transforms/core/config_helper.h>
#include <epoch_script/transforms/core/itransform.h>
#include <epoch_script/transforms/core/transform_configuration.h>
#include <epoch_script/transforms/core/transform_registry.h>
#include "transforms/components/datetime/datetime_diff.h"
#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_string.hpp>
#include <epoch_core/catch_defs.h>
#include <epoch_frame/factory/index_factory.h>
#include <epoch_frame/factory/array_factory.h>
#include <epoch_frame/datetime.h>

using namespace epoch_core;
using namespace epoch_script;
using namespace epoch_script::transform;
using namespace std::chrono_literals;
using namespace epoch_frame;

// Helper function to create a test dataframe with two timestamp columns
DataFrame createTestDataFrameWithTwoTimestamps() {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d},
       epoch_frame::DateTime{2020y, std::chrono::January, 3d}});

  // Create two timestamp columns
  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d, 10h, 0min, 0s},
      epoch_frame::DateTime{2020y, std::chrono::February, 15d, 14h, 30min, 0s},
      epoch_frame::DateTime{2020y, std::chrono::March, 1d, 0h, 0min, 0s}};

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d, 12h, 0min, 0s},  // 2 hours later
      epoch_frame::DateTime{2020y, std::chrono::February, 16d, 14h, 30min, 0s},  // 1 day later
      epoch_frame::DateTime{2020y, std::chrono::April, 1d, 0h, 0min, 0s}};  // 31 days later

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("price", arrow::float64()),
      arrow::field("start_date", start_array->type()),
      arrow::field("end_date", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {
      epoch_frame::factory::array::make_numeric_array<double>({10.0, 20.0, 30.0}),
      start_array,
      end_array};

  auto table = arrow::Table::Make(schema, arrays);
  return DataFrame(index, table);
}

TEST_CASE("datetime_diff - days unit", "[datetime][diff]") {
  auto input = createTestDataFrameWithTwoTimestamps();

  auto config = datetime_diff_cfg("days_diff", "start_date", "end_date", "days",
          epoch_script::EpochStratifyXConstants::instance().DAILY_FREQUENCY);

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  REQUIRE(output.size() == 3);
  REQUIRE(output.contains(config.GetOutputId()));

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  // Differences: 0 days, 1 day, 31 days
  REQUIRE(diff_array->Value(0) == 0);
  REQUIRE(diff_array->Value(1) == 1);
  REQUIRE(diff_array->Value(2) == 31);
}

TEST_CASE("datetime_diff - hours unit", "[datetime][diff]") {
  auto input = createTestDataFrameWithTwoTimestamps();
  auto config = datetime_diff_cfg("hours_diff", "start_date", "end_date", "hours",
          epoch_script::EpochStratifyXConstants::instance().DAILY_FREQUENCY);

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  // Differences: 2 hours, 24 hours, 744 hours (31 days)
  REQUIRE(diff_array->Value(0) == 2);
  REQUIRE(diff_array->Value(1) == 24);
  REQUIRE(diff_array->Value(2) == 31 * 24);  // 31 days = 744 hours
}

TEST_CASE("datetime_diff - minutes unit", "[datetime][diff]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d}});

  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d, 10h, 0min, 0s}};

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d, 10h, 30min, 0s}};

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("start_time", start_array->type()),
      arrow::field("end_time", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {start_array, end_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: minutes_diff
options:
  unit: "minutes"
inputs:
  SLOT: start_time
  SLOT1: end_time
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(diff_array->Value(0) == 30);  // 30 minutes difference
}

TEST_CASE("datetime_diff - seconds unit", "[datetime][diff]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d}});

  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d, 10h, 0min, 0s}};

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d, 10h, 0min, 45s}};

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("start_time", start_array->type()),
      arrow::field("end_time", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {start_array, end_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: seconds_diff
options:
  unit: "seconds"
inputs:
  SLOT: start_time
  SLOT1: end_time
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(diff_array->Value(0) == 45);  // 45 seconds difference
}

TEST_CASE("datetime_diff - weeks unit", "[datetime][diff]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d}});

  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d},
      epoch_frame::DateTime{2020y, std::chrono::January, 15d}};

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 15d},  // 2 weeks later
      epoch_frame::DateTime{2020y, std::chrono::February, 15d}};  // ~4.4 weeks later

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("start_date", start_array->type()),
      arrow::field("end_date", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {start_array, end_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: weeks_diff
options:
  unit: "weeks"
inputs:
  SLOT: start_date
  SLOT1: end_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(diff_array->Value(0) == 2);  // 14 days = 2 weeks
  REQUIRE(diff_array->Value(1) == 4);  // 31 days = 4 weeks (truncated)
}

TEST_CASE("datetime_diff - months unit", "[datetime][diff]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d}});

  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d},
      epoch_frame::DateTime{2020y, std::chrono::January, 15d}};

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::April, 1d},    // 3 months later
      epoch_frame::DateTime{2021y, std::chrono::January, 15d}}; // 12 months later

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("start_date", start_array->type()),
      arrow::field("end_date", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {start_array, end_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: months_diff
options:
  unit: "months"
inputs:
  SLOT: start_date
  SLOT1: end_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(diff_array->Value(0) == 3);   // 3 months
  REQUIRE(diff_array->Value(1) == 12);  // 12 months
}

TEST_CASE("datetime_diff - quarters unit", "[datetime][diff]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d}});

  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d},    // Q1
      epoch_frame::DateTime{2020y, std::chrono::January, 1d}};   // Q1

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::July, 1d},       // Q3
      epoch_frame::DateTime{2021y, std::chrono::January, 1d}};   // Q1 next year

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("start_date", start_array->type()),
      arrow::field("end_date", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {start_array, end_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: quarters_diff
options:
  unit: "quarters"
inputs:
  SLOT: start_date
  SLOT1: end_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(diff_array->Value(0) == 2);  // Q1 to Q3 = 2 quarters
  REQUIRE(diff_array->Value(1) == 4);  // Q1 2020 to Q1 2021 = 4 quarters
}

TEST_CASE("datetime_diff - years unit", "[datetime][diff]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d},
       epoch_frame::DateTime{2020y, std::chrono::January, 2d}});

  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 1d},
      epoch_frame::DateTime{2018y, std::chrono::June, 15d}};

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2023y, std::chrono::January, 1d},   // 3 years later
      epoch_frame::DateTime{2020y, std::chrono::June, 15d}};    // 2 years later

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("start_date", start_array->type()),
      arrow::field("end_date", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {start_array, end_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: years_diff
options:
  unit: "years"
inputs:
  SLOT: start_date
  SLOT1: end_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(diff_array->Value(0) == 3);  // 3 years
  REQUIRE(diff_array->Value(1) == 2);  // 2 years
}

TEST_CASE("datetime_diff - negative differences", "[datetime][diff]") {
  auto index = epoch_frame::factory::index::make_datetime_index(
      {epoch_frame::DateTime{2020y, std::chrono::January, 1d}});

  // Start is AFTER end - should give negative result
  std::vector<epoch_frame::DateTime> start_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 10d}};

  std::vector<epoch_frame::DateTime> end_timestamps = {
      epoch_frame::DateTime{2020y, std::chrono::January, 5d}};

  auto start_array = epoch_frame::factory::array::make_timestamp_array(start_timestamps);
  auto end_array = epoch_frame::factory::array::make_timestamp_array(end_timestamps);

  arrow::FieldVector fields = {
      arrow::field("start_date", start_array->type()),
      arrow::field("end_date", end_array->type())};
  auto schema = arrow::schema(fields);

  std::vector<std::shared_ptr<arrow::Array>> arrays = {start_array, end_array};

  auto table = arrow::Table::Make(schema, arrays);
  auto input = DataFrame(index, table);

  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: negative_diff
options:
  unit: "days"
inputs:
  SLOT: start_date
  SLOT1: end_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  REQUIRE(diff_array->Value(0) == -5);  // end is 5 days before start
}

TEST_CASE("datetime_diff - default unit is days", "[datetime][diff]") {
  auto input = createTestDataFrameWithTwoTimestamps();

  // Don't specify unit option - should default to days
  TransformConfiguration config =
      TransformConfiguration{TransformDefinition{YAML::Load(std::format(
          R"(
type: datetime_diff
id: default_diff
inputs:
  SLOT: start_date
  SLOT1: end_date
timeframe: {}
)",
          epoch_script::EpochStratifyXConstants::instance()
              .DAILY_FREQUENCY.Serialize()))}};

  auto transformBase = MAKE_TRANSFORM(config);
  auto transform = dynamic_cast<ITransform *>(transformBase.get());

  DataFrame output = transform->TransformData(input);

  auto series = output[config.GetOutputId()];
  auto diff_array = std::static_pointer_cast<arrow::Int64Array>(series.array());

  // Should compute difference in days by default
  REQUIRE(diff_array->Value(0) == 0);
  REQUIRE(diff_array->Value(1) == 1);
  REQUIRE(diff_array->Value(2) == 31);
}
