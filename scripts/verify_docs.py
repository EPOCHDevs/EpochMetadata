#!/usr/bin/env python3
"""
Verify documentation accuracy against actual transform metadata.

This script:
1. Parses core-transforms.md to extract documented transforms
2. Loads transform_metadata.json (generated by dump_transform_metadata)
3. Compares and reports discrepancies

Usage:
    python3 verify_docs.py <metadata.json> <core-transforms.md> [output_report.md]
"""

import json
import re
import sys
from pathlib import Path
from typing import Dict, List, Set, Optional, Tuple
from dataclasses import dataclass, field
from collections import defaultdict


@dataclass
class Option:
    """Documented transform option"""
    name: str
    type_: str
    default: Optional[str] = None
    required: bool = False


@dataclass
class InputOutput:
    """Input or output"""
    name: str
    type_: str


@dataclass
class DocumentedTransform:
    """Transform as documented in markdown"""
    id: str
    section: str
    line_number: int
    options: List[Option] = field(default_factory=list)
    inputs: List[InputOutput] = field(default_factory=list)
    outputs: List[InputOutput] = field(default_factory=list)
    examples: List[str] = field(default_factory=list)


@dataclass
class Discrepancy:
    """A discrepancy between docs and code"""
    transform_id: str
    category: str  # 'missing', 'extra', 'option_mismatch', 'input_mismatch', 'output_mismatch'
    severity: str  # 'error', 'warning', 'info'
    message: str
    doc_line: Optional[int] = None


class DocumentationVerifier:
    def __init__(self, metadata_path: Path, docs_path: Path):
        self.metadata_path = metadata_path
        self.docs_path = docs_path
        self.actual_transforms: Dict[str, dict] = {}
        self.documented_transforms: Dict[str, DocumentedTransform] = {}
        self.discrepancies: List[Discrepancy] = []

    def load_actual_metadata(self):
        """Load actual transform metadata from JSON"""
        with open(self.metadata_path) as f:
            transforms = json.load(f)
        self.actual_transforms = {t['id']: t for t in transforms}
        print(f"✓ Loaded {len(self.actual_transforms)} transforms from metadata")

    def parse_documentation(self):
        """Parse core-transforms.md to extract documented transforms"""
        with open(self.docs_path) as f:
            content = f.read()
            lines = content.split('\n')

        current_section = None
        current_transform = None
        in_options = False
        in_inputs = False
        in_outputs = False
        in_example = False

        for i, line in enumerate(lines, 1):
            # Detect section headers (## Data Sources & Execution, etc.)
            if line.startswith('## '):
                current_section = line[3:].strip()
                continue

            # Detect transform headers (### ema, ### rsi, etc.)
            if line.startswith('### '):
                if current_transform:
                    self.documented_transforms[current_transform.id] = current_transform

                transform_id = line[4:].strip().lower()
                current_transform = DocumentedTransform(
                    id=transform_id,
                    section=current_section or "Unknown",
                    line_number=i
                )
                in_options = False
                in_inputs = False
                in_outputs = False
                in_example = False
                continue

            if not current_transform:
                continue

            # Detect **Options:** section
            if line.strip().startswith('**Options:**'):
                in_options = True
                in_inputs = False
                in_outputs = False
                continue

            # Detect **Inputs:** section
            if line.strip().startswith('**Inputs:**'):
                in_options = False
                in_inputs = True
                in_outputs = False
                continue

            # Detect **Outputs:** section
            if line.strip().startswith('**Outputs:**'):
                in_options = False
                in_inputs = False
                in_outputs = True
                continue

            # End sections
            if line.startswith('**Use Cases:**') or line.startswith('**Example:**') or line.startswith('**Interpretation:**'):
                in_options = False
                in_inputs = False
                in_outputs = False

            # Parse option (- `period` (Integer, required) - Description)
            if in_options and line.strip().startswith('- `'):
                match = re.match(r'-\s+`(\w+)`\s+\((\w+)(?:,\s+(.+?))?\)\s+-', line.strip())
                if match:
                    name, type_, meta = match.groups()
                    default = None
                    required = False

                    if meta:
                        if 'required' in meta:
                            required = True
                        default_match = re.search(r'default[=:]?\s*(\S+)', meta)
                        if default_match:
                            default = default_match.group(1)

                    current_transform.options.append(Option(
                        name=name,
                        type_=type_,
                        default=default,
                        required=required
                    ))

            # Parse output (- `result` - Description)
            if in_outputs and line.strip().startswith('- `'):
                match = re.match(r'-\s+`(\w+)`\s+-\s+(.+)', line.strip())
                if match:
                    name, desc = match.groups()
                    # Try to infer type from description
                    type_ = "Decimal"  # Default assumption
                    if "boolean" in desc.lower():
                        type_ = "Boolean"
                    elif "integer" in desc.lower():
                        type_ = "Integer"
                    elif "string" in desc.lower():
                        type_ = "String"

                    current_transform.outputs.append(InputOutput(
                        name=name,
                        type_=type_
                    ))

            # Detect example code blocks
            if line.strip().startswith('```python'):
                in_example = True
                continue

            if in_example and line.strip() == '```':
                in_example = False
                continue

            if in_example:
                current_transform.examples.append(line)

        # Add last transform
        if current_transform:
            self.documented_transforms[current_transform.id] = current_transform

        print(f"✓ Parsed {len(self.documented_transforms)} transforms from documentation")

    def verify(self):
        """Compare documented transforms against actual metadata"""
        documented_ids = set(self.documented_transforms.keys())
        actual_ids = set(self.actual_transforms.keys())

        # Check for transforms documented but not in code
        for doc_id in documented_ids - actual_ids:
            doc_transform = self.documented_transforms[doc_id]
            self.discrepancies.append(Discrepancy(
                transform_id=doc_id,
                category='missing_in_code',
                severity='error',
                message=f"Transform '{doc_id}' is documented but does not exist in the codebase",
                doc_line=doc_transform.line_number
            ))

        # Check for transforms in code but not documented
        for actual_id in actual_ids - documented_ids:
            self.discrepancies.append(Discrepancy(
                transform_id=actual_id,
                category='not_documented',
                severity='warning',
                message=f"Transform '{actual_id}' exists in code but is not documented",
            ))

        # Check transforms that are both documented and in code
        for transform_id in documented_ids & actual_ids:
            self._verify_transform(transform_id)

        print(f"✓ Found {len(self.discrepancies)} discrepancies")

    def _verify_transform(self, transform_id: str):
        """Verify a single transform"""
        doc = self.documented_transforms[transform_id]
        actual = self.actual_transforms[transform_id]

        # Verify options
        if 'options' in actual:
            actual_options = {opt['id']: opt for opt in actual['options']}
            doc_options = {opt.name: opt for opt in doc.options}

            # Check documented options exist in code
            for opt_name, opt in doc_options.items():
                if opt_name not in actual_options:
                    self.discrepancies.append(Discrepancy(
                        transform_id=transform_id,
                        category='option_mismatch',
                        severity='error',
                        message=f"Option '{opt_name}' documented but not in code",
                        doc_line=doc.line_number
                    ))
                else:
                    # Check type matches
                    actual_type = actual_options[opt_name]['type']
                    if opt.type_.lower() != actual_type.lower():
                        self.discrepancies.append(Discrepancy(
                            transform_id=transform_id,
                            category='option_mismatch',
                            severity='warning',
                            message=f"Option '{opt_name}' type mismatch: docs say '{opt.type_}', code says '{actual_type}'",
                            doc_line=doc.line_number
                        ))

                    # Check default matches
                    if opt.default and 'default' in actual_options[opt_name]:
                        actual_default = str(actual_options[opt_name]['default'])
                        if str(opt.default) != actual_default:
                            self.discrepancies.append(Discrepancy(
                                transform_id=transform_id,
                                category='option_mismatch',
                                severity='info',
                                message=f"Option '{opt_name}' default mismatch: docs say '{opt.default}', code says '{actual_default}'",
                                doc_line=doc.line_number
                            ))

            # Check for undocumented options in code
            for opt_name in actual_options.keys():
                if opt_name not in doc_options:
                    self.discrepancies.append(Discrepancy(
                        transform_id=transform_id,
                        category='option_mismatch',
                        severity='warning',
                        message=f"Option '{opt_name}' exists in code but not documented",
                        doc_line=doc.line_number
                    ))

        # Verify outputs
        if 'outputs' in actual:
            actual_outputs = {out['id']: out for out in actual['outputs']}
            doc_outputs = {out.name: out for out in doc.outputs}

            for out_name in doc_outputs.keys():
                if out_name not in actual_outputs:
                    self.discrepancies.append(Discrepancy(
                        transform_id=transform_id,
                        category='output_mismatch',
                        severity='error',
                        message=f"Output '{out_name}' documented but not in code",
                        doc_line=doc.line_number
                    ))

            for out_name in actual_outputs.keys():
                if out_name not in doc_outputs:
                    self.discrepancies.append(Discrepancy(
                        transform_id=transform_id,
                        category='output_mismatch',
                        severity='warning',
                        message=f"Output '{out_name}' exists in code but not documented",
                        doc_line=doc.line_number
                    ))

    def generate_report(self, output_path: Path):
        """Generate markdown report"""
        report_lines = [
            "# Transform Documentation Verification Report",
            "",
            f"**Generated**: {Path(sys.argv[0]).name}",
            f"**Metadata**: {self.metadata_path}",
            f"**Documentation**: {self.docs_path}",
            "",
            "## Summary",
            "",
            f"- **Actual transforms in codebase**: {len(self.actual_transforms)}",
            f"- **Documented transforms**: {len(self.documented_transforms)}",
            f"- **Total discrepancies**: {len(self.discrepancies)}",
            "",
        ]

        # Group by severity
        by_severity = defaultdict(list)
        for disc in self.discrepancies:
            by_severity[disc.severity].append(disc)

        for severity in ['error', 'warning', 'info']:
            count = len(by_severity[severity])
            report_lines.append(f"- **{severity.upper()}**: {count}")

        report_lines.extend([
            "",
            "---",
            "",
            "## Coverage Analysis",
            "",
            f"**Documentation coverage**: {len(self.documented_transforms)} / {len(self.actual_transforms)} ({100 * len(self.documented_transforms) / max(len(self.actual_transforms), 1):.1f}%)",
            "",
        ])

        # List undocumented transforms
        undocumented = [d for d in self.discrepancies if d.category == 'not_documented']
        if undocumented:
            report_lines.extend([
                "### Undocumented Transforms",
                "",
                f"{len(undocumented)} transforms exist in the codebase but are not documented:",
                "",
            ])

            for disc in sorted(undocumented, key=lambda d: d.transform_id):
                actual = self.actual_transforms[disc.transform_id]
                category = actual.get('category', 'Unknown')
                report_lines.append(f"- **{disc.transform_id}** ({category})")

            report_lines.append("")

        # Detailed discrepancies by transform
        report_lines.extend([
            "---",
            "",
            "## Detailed Discrepancies",
            "",
        ])

        by_transform = defaultdict(list)
        for disc in self.discrepancies:
            if disc.category != 'not_documented':  # Already listed above
                by_transform[disc.transform_id].append(disc)

        if not by_transform:
            report_lines.append("✓ **No discrepancies found for documented transforms**")
        else:
            for transform_id in sorted(by_transform.keys()):
                discs = by_transform[transform_id]
                doc = self.documented_transforms.get(transform_id)
                doc_line = f" (docs/epochscript/core-transforms.md:{doc.line_number})" if doc else ""

                report_lines.extend([
                    f"### `{transform_id}`{doc_line}",
                    "",
                ])

                for disc in discs:
                    icon = {"error": "❌", "warning": "⚠️", "info": "ℹ️"}[disc.severity]
                    report_lines.append(f"{icon} **{disc.severity.upper()}**: {disc.message}")

                report_lines.append("")

        # Write report
        output_path.write_text('\n'.join(report_lines))
        print(f"✓ Report written to {output_path}")

    def run(self, output_path: Path):
        """Run full verification"""
        print("Starting documentation verification...")
        self.load_actual_metadata()
        self.parse_documentation()
        self.verify()
        self.generate_report(output_path)
        print(f"\n{'='*60}")
        print(f"Verification complete: {len(self.discrepancies)} discrepancies found")
        print(f"Report: {output_path}")
        print(f"{'='*60}")


def main():
    if len(sys.argv) < 3:
        print("Usage: verify_docs.py <metadata.json> <core-transforms.md> [output_report.md]")
        sys.exit(1)

    metadata_path = Path(sys.argv[1])
    docs_path = Path(sys.argv[2])
    output_path = Path(sys.argv[3]) if len(sys.argv) > 3 else Path("VERIFICATION_REPORT.md")

    if not metadata_path.exists():
        print(f"Error: Metadata file not found: {metadata_path}")
        sys.exit(1)

    if not docs_path.exists():
        print(f"Error: Documentation file not found: {docs_path}")
        sys.exit(1)

    verifier = DocumentationVerifier(metadata_path, docs_path)
    verifier.run(output_path)


if __name__ == '__main__':
    main()
